# API 签名认证对接文档

## 1. 请求头 (Request Headers)

每个 API 请求都 **必须** 包含以下 HTTP 请求头：

* `ts`: **Unix 时间戳** (自 Epoch 以来的秒数)，表示请求发起的时间。
    * 示例: `1678886400`
* `randStr`: **随机字符串**，每次请求必须保证唯一性，用于防止重放。
    * 示例: `aK3j9sLp2dR7mXq`
* `sign`: 计算得出的**签名字符串**。
    * 示例: `A1B2C3D4E5F60708090A0B0C0D0E0F101112131415161718191A1B1C1D1E1F20`

**重要说明:**
* 请求方式为 `POST`，`application/json` 。
* 所有序列化字符串都必须使用 UTF8 编码 。
* 服务器会拒绝 `ts` 时间戳与服务器当前时间相差超过 **60 秒** 的请求。
* 缺少 `ts`、`randStr` 或 `sign` 中任何一个请求头，都将导致 `400 Bad Request` 错误。

---

## 2. 签名生成流程 ✍️

签名 (`sign`) 是通过对一个特定构造的字符串进行 **SHA256 哈希运算**，然后将哈希结果转换为**大写十六进制字符串**而得到的。

请严格按照以下步骤生成签名：

### 步骤 1: 构建待哈希的字符串

按照**严格的顺序**拼接以下内容，中间**不加任何分隔符**：

1.  经过**序列化后的请求体** (UTF8 string)。
2.  请求头中的 `ts` 值 (UTF8 string)。
3.  请求头中的 `randStr` 值 (UTF8 string)。
4.  一个预定义的 **盐值 (salt)**。(UTF8 string)
    * 注意：后续约定一个固定值。

### 步骤 2: 计算 SHA256 哈希值

1.  对在步骤 2 中构建的完整字符串进行 **SHA256 哈希运算**。
2.  SHA256运算结果转为16进制大写字符串。得到 `sign`。

## 3. 服务端验证逻辑

服务器端会执行以下校验流程：

1.  检查 `ts`、`randStr` 和 `sign` 请求头是否存在。
2.  校验 `ts` 是否在当前服务器时间的 60 秒有效窗口期内。
3.  读取请求体。
4.  服务器将使用接收到的 `ts`、`randStr`、请求体以及预定义的 `salt`，严格按照上述签名生成步骤（步骤 1 至步骤 4）独立计算一次签名。
5.  比较请求头中接收到的 `sign` 值与服务器端计算得到的签名。
    * 如果两者**一致**，则请求被视为有效，继续处理后续业务逻辑。
    * 如果两者**不一致**，服务器将响应 `HTTP 403 Forbidden` 错误。
